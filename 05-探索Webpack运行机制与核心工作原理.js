/**
 * 一,工作过程简介
 * 如图05.1实例图
 * 要快速理解Webpack打包的核心工作过程,以一个普通的前端项目为例,项目中一般都会散落着
 * 各种各样的代码及资源文件.
 * 比如JS,CSS,图片,字体等,这些文件在Webpack的思想中都属于当前项目中的一个模块.Webpack
 * 可以通过打包,将它们最终聚集到一起.Webpack在整个打包的过程中:
 * 
 * > 通过Loader处理特殊类型资源的加载,例如加载样式,图片;
 * > 通过Plugin实现各种自动化的构建任务,例如自动压缩,自动发布.
 * 
 * 具体来看打包的过程,Webpack启动后,会根据我们的配置,找到项目中的某个指定文件(一般这个文件都会是一个JS文件)作为入口.
 * 然后顺着入口文件的代码,根据代码中出现的import(ES Modules) 或者是 require(CommonJS)之类的语句,解析推断出来这个
 * 文件所依赖的资源模块,然后在分别去解析每个资源模块的依赖,周而复始,最后形成整个项目所有用到的文件之间的依赖关系树.
 * 
 * 有了这个依赖关系树过后,Webpack会遍历(递归)这个依赖树,找到每个节点对应的资源文件,然后根据配置选项中的Loader配置,交给
 * 对应的Loader去加载这个模块,最后将加载的结果放入bundle.js(打包结果)中,从而实现整个项目的打包.
 * 
 * 对于依赖模块中无法通过JavaScript代码表示的资源模块,例如图片或字体文件,一般的Loader会将它们单独作为资源文件拷贝到输出
 * 目录中,然后将这个资源文件所对应的访问路径作为这个模块的导出成员暴露给外部.
 * 
 * 整个打包过程中,Loader机制起了很重要的作用,因为如果没有Loader的话,Webpack就无法实现各种各样类型的资源文件加载,那Webpack
 * 也就只能算是一个来合并JS模块代码的工具.
 * 
 * 至于自定义插件机制,在04课时中也详细介绍过,它并不会影响Webpack的核心工作过程,只是Webpack为了提供一个强大的扩展能力,它为整个
 * 工作过程的每个环节都预制了一个钩子,也就是说我们可以通过插件往Webpack工作过程的任意环节植入一些自定义的任务,从而扩展Webpack
 * 打包功能以外的能力.
 */

/**
 * 二,工作原理剖析
 * 先提炼出Webpack核心工作过程中的关键环节,明确"查阅"源码的思路:
 * 1> Webpack CLI 启动打包流程
 * 2> 载入Webpack核心模块,创建Compiler对象;
 * 3> 使用Compiler对象开始编译整个项目;
 * 4> 从入口文件开始,解析模块依赖,形成依赖关系树;
 * 5> 递归依赖树,将每个模块交给对应的Loader处理;
 * 6> 合并Loader处理完的结果,将打包结果输出到dist目录;
 */

/**
 * 1. Webpack CLI
 * 从Webpack 4 开始 Webpack 的CLI部分就被单独抽到了 webpack-cli 模块中,目的就是为了增强Webpack本身的灵活性.
 * 这里分析的是V3.3.11版本的webpack-cli,可参考:https://github.com/webpack/webpack-cli/tree/v3.3.11
 * 
 * Webpack CLI的作用就是将CLI参数和Webpack配置文件中配置整合,得到一个完整的配置对象.
 * 这部分操作在webpack-cli的入口文件bin/cli.js中.
 * 首先,Webpack CLI 会通过 yargs 模块解析CLI参数,所谓CLI参数值的就是我们在运行webpack命令是通过命令行传入的
 * 参数,例如 --mode=production,具体位置如下图:
 * 
 * 05.2 示例图
 * 
 * 紧接着后面,调用了 bin/utils/convert-argv.js模块,将得到的命令行参数转换为Webpack的配置选项对象,如下图:
 * 
 * 05.3 实例图
 * 
 * 在convert-argv.js工作过程中,首先为传递过来的命令行参数设置了默认值,然后判断了命令行参数中是否制定了一个具体的配置
 * 文件路径,如果指定了就加载指定配置文件,反之则需要根据默认配置文件加载规则找到配置文件,如下:
 * 
 * 05.4 实例图
 * 
 * 找到配置文件过后,将配置文件中的配置和CLI参数中的配置合并,如果出现重复的情况,会优先使用CLI参数,最终得到一个完整的配置选项.
 * 
 * 有了配置选项过后,开始载入Webpack核心模块,传入配置选项,创建Compiler对象,这个Compiler对象就是整个Webpack工作过程中
 * 最核心的对象了,负责完成整个项目的构建工作.如下:
 * 
 * 05.5 示例图
 * 
 */

/**
 * 2. 创建Compiler对象
 * 
 */