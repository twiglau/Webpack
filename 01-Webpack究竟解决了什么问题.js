/**
 * Webpack 最初的目标就是实现前端项目的模块化,也就是说它所解决的问题是
 * 如何在前端项目中更高效地管理和维护项目中的每一个资源.
 * 
 * 一,模块化的演进过程
 * 
 * 1. Stage 1 - 文件划分方式
 * 2. Stage 2 - 命名空间方式
 * 后来,我们约定每个模块只暴露一个全局对象,所有模块成员都挂载到这个全局对象中,具体做法是在第一阶段
 * 基础上,通过将每个模块 "包裹" 为一个全局对象的形式实现,这种方式就好像是为模块内的成员添加了"命名
 * 空间",所以我们又称之为命名空间方式.
 * 3. Stage 3 - IIFE
 * 使用立即执行函数表达式(IIFE, Immediately-Invoked Function Expression) 为模块提供私有空间,
 * 具体做法是将每个模块成员都放在一个立即执行函数所形成的私有作用域中, 对于需要暴露给外部的成员,通
 * 过挂到全局对象上的方式实现.
 * 4. Stage 4 - IIFE 依赖参数
 * 在 IIFE 的基础之上,我们还可以利用 IIFE 参数作为依赖声明使用,这使得每一个模块之间的依赖关系变得
 * 更加明显.
 */

/**
 * 二, 模块加载的问题
 * 以上4个阶段是早期的开发者在没有工具和规范的情况下对模块化的落地方式,这些方式确实解决了很多在前端
 * 领域实现模块化的问题,但是仍然存在一些没有解决的问题.
 * 
 * 最明显的问题就是: 模块的加载. 在这几种方式中虽然都解决了模块代码的组织问题,但模块加载的问题却被忽略了,
 * 我们都是通过 script 标签的方式直接在页面中引入的这些模块,这意味着模块的加载并不受代码的控制,时间久了
 * 维护起来会十分麻烦. 试想一个,如果你的代码需要用到某个模块,如果 HTML 中忘记引入这个模块,又或是代码中
 * 移除了某个模块的使用,而 HTML 还忘记删除该模块的引用,都会引起很多问题和不不要的麻烦.
 * 
 * 更为理想的方式应该是在页面中引入一个 JS 入口文件, 其余用到的模块可以通过代码控制,按需加载进来.
 */

/**
 * 三,模块化规范的出现
 * >> 一个统一的模块化标准规范
 * >> 一个可以自动加载模块的基础库
 * 
 * 1. CommonJS规范,它是Node.js中所遵循的模块规范,该规范约定,一个文件就是一个模块,每个模块都有
 * 单独的作用域,通过module.exports导出成员,在通过 require 函数载入模块.现如今的前端开发者应该
 * 对其有所了解,但是如果我们想要在浏览器端直接使用这个规范,那就会出现一些新的问题.
 * 如果你对Node.js 的模块加载机制有所了解,那么你应该知道,CommonJS 约定的是以同步的方式加载模块,
 * 因为Node.js执行机制是在启动时加载模块,执行过程中只是使用模块,所以这种方式不会有问题,但是如果
 * 要在浏览器端使用同步的加载模式,就会引起大量的同步模式请求,导致应用运行效率低下.
 * 
 * 2.所以早期指定前端模块化标准时,并没有直接选择CommonJS规范,而是专门为浏览器端重新设计了一个规范,
 * 叫做 AMD (Asynchronous Module Definition)规范,即异步模块定义规范. 同期还推出了一个非常
 * 出名的库,叫做 Require.js, 它除了实现了 AMD 模块化规范,本身也是一个非常强大的模块加载器.
 * 
 * 在AMD规范中约定每个模块通过 define() 函数定义,这个函数默认可以接收两个参数,第一个参数是一个数组,
 * 用于声明此模块的依赖项; 第二个参数是一个函数,参数与前面的依赖项一一对应,每一项分别对应依赖项模块的
 * 导出成员,这个函数的作用就是为当前模块提供一个私有空间. 如果在当前模块中需要向外部导出成员,可以通过
 * return 的方式实现.
 * 
 * AMD 规范定义一个模块
 * define(['jquery','./module2.js'],function($,module2){
 *     return {
 *        start: function() {
 *            $('body').animate({ margin: '200px'})
 *        }
 *     }
 * })
 * 
 * 除此之外, Require.js 还提供了一个 require() 函数用于自动加载模块,用法与 define() 函数类似,区别在
 * 于 require() 只能用来载入模块, 而 define() 还可以定义模块. 当Require.js 需要加载一个模块是,内部
 * 就会自动创建script 标签去请求并执行相应模块的代码.
 * 
 * AMD 规范载入一个模块
 * require(['./modules/module1.js'],function (module1) {
 *    module1.start()
 * })
 * 
 * 目前绝大多数第三方库都支持 AMD 规范, 但是它使用起来相对复杂,而且当项目中模块划分过于细致时,就会出现
 * 同一个页面对js文件的请求次数过多的情况,从而导致效率降低.在当时的环境背景下, AMD规范为前端模块化提供
 * 了一个标准,但这只是一种妥协的实现方式,并不能成为最终的解决方案.
 * 
 * 同期出现的规范还有淘宝的 Sea.js, 只不过它实现的是另外一个标准,叫做CMD, 这个标准类似于 CommonJS,在
 * 使用上基本和Require.js相同,可以算上是重复的轮子. 但随着前端技术的发展,Sea.js后来也被Require.js兼容了.
 * 
 * //Require.js 兼容类似 CommonJS 规范
 * //所有模块都通过 define 来定义
 * define(function (require,exports,module) {
 *       //通过 require 引入依赖
 *      var $ = require('jquery')
 *       //通过 exports 或者 module.exports 对外暴露成员
 *      module.exports = function () {
 *        console.log('module 2~')
 *        $('body').append('<p>modules2</p>')
 *      }
 * })
 */


/**
 * 四,模块化的标准规范
 * >> 在Node.js环境中,我们遵循 CommonJS 规范来组织模块
 * >> 在浏览器环境中,我们遵循 ES Modules 规范
 * 
 * 而且在最新的Node.js 提案中表示,Node环境也会逐渐趋向于ES Modules规范,也就是说作为现阶段的前端开发者,
 * 应该重点掌握ES Modules规范.
 * 因为CommonJS属于内置模块系统,所以在Node.js环境中使用时不存在环境支持问题,只需要直接遵循标准使用require
 * 和module即可.
 * 
 * ES Modules 是ECMAScript 2015 (ES6) 中才定义的模块系统,也就是说它是近几年才指定的标准,所以肯定会存在
 * 环境兼容的问题.
 * 
 */

/**
 * 五,模块打包工具的出现
 * 模块化可以帮助我们更好地解决复杂应用开发过程中的代码组织问题,但是随着模块化思想的引入,我们的前端
 * 应用又会产生了一些新的问题,如:
 * 
 * >> 首先,我们所使用的 ES Modules 模块系统本身就存在环境兼容问题,尽管现如今主流浏览器的最新版本都支持这一
 * 特性,但是目前还无法保证用户的浏览器使用情况.所以我们还需要解决兼容问题.
 * 
 * >> 其次,模块化的方式划分出来的模块文件过多,而前端应用又运行在浏览器中,每一个文件都需要单独从服务器请求回来.
 * 零散的模块文件必然会导致浏览器的频繁发送网络请求,影响应用的工作效率.
 * 
 * >> 最后,谈一下在实现JS模块化的基础上的发散. 随着应用日益复杂,在前端应用开发过程中不仅仅只有 JavaScript 代码
 * 需要模块化, HTML 和 CSS 这些资源文件也会面临需要被模块化的问题. 而且从宏观角度来看,这些文件也都应该看作前端
 * 应用中的一个模块,只不过这些模块的种类和用途跟 JavaScript 不同.
 * 
 * 对于开发过程而言,模块化肯定是必要的,所以我们需要在前面所说的模块化实现的基础之上引入更好的方案或者工具,去解决
 * 上面提出的 3 个问题,让我们的应用在开发阶段继续享受模块化带来的优势,又不必担心对生产环境所产生的影响.
 * 
 * 更好的方案或者工具提出一些设想:
 * >> 第一,它需要具备编译代码的能力,也就是将我们开发阶段编写的那些包含新特性的代码转换为能过兼容大多数环境的代码,
 * 解决我们所面临的环境兼容问题.
 * 
 * >> 第二,能过将散落的模块再打包到一起,这样就解决了浏览器频繁请求模块文件的问题. 这里需要注意,只是在开发阶段才
 * 需要模块化的文件划分,因为它能够帮我们更好地组织代码,到了实际运行阶段,这种划分就没有必要了.
 * 
 * >> 第三,它需要支持不同种类的前端模块类型,也就是说可以将开发过程中涉及的样式,图片,字体等所有资源文件都作为模块
 * 使用,这样我们就拥有了一个统一的模块化方案,所有资源文件的加载都可以通过代码控制,与业务代码统一维护,更为合理.
 */





