/**
 * 一,工作过程简介
 * 如图05.1实例图
 * 要快速理解Webpack打包的核心工作过程,以一个普通的前端项目为例,项目中一般都会散落着
 * 各种各样的代码及资源文件.
 * 比如JS,CSS,图片,字体等,这些文件在Webpack的思想中都属于当前项目中的一个模块.Webpack
 * 可以通过打包,将它们最终聚集到一起.Webpack在整个打包的过程中:
 * 
 * > 通过Loader处理特殊类型资源的加载,例如加载样式,图片;
 * > 通过Plugin实现各种自动化的构建任务,例如自动压缩,自动发布.
 * 
 * 具体来看打包的过程,Webpack启动后,会根据我们的配置,找到项目中的某个指定文件(一般这个文件都会是一个JS文件)作为入口.
 * 然后顺着入口文件的代码,根据代码中出现的import(ES Modules) 或者是 require(CommonJS)之类的语句,解析推断出来这个
 * 文件所依赖的资源模块,然后在分别去解析每个资源模块的依赖,周而复始,最后形成整个项目所有用到的文件之间的依赖关系树.
 * 
 * 有了这个依赖关系树过后,Webpack会遍历(递归)这个依赖树,找到每个节点对应的资源文件,然后根据配置选项中的Loader配置,交给
 * 对应的Loader去加载这个模块,最后将加载的结果放入bundle.js(打包结果)中,从而实现整个项目的打包.
 * 
 * 对于依赖模块中无法通过JavaScript代码表示的资源模块,例如图片或字体文件,一般的Loader会将它们单独作为资源文件拷贝到输出
 * 目录中,然后将这个资源文件所对应的访问路径作为这个模块的导出成员暴露给外部.
 * 
 * 整个打包过程中,Loader机制起了很重要的作用,因为如果没有Loader的话,Webpack就无法实现各种各样类型的资源文件加载,那Webpack
 * 也就只能算是一个来合并JS模块代码的工具.
 * 
 * 至于自定义插件机制,在04课时中也详细介绍过,它并不会影响Webpack的核心工作过程,只是Webpack为了提供一个强大的扩展能力,它为整个
 * 工作过程的每个环节都预制了一个钩子,也就是说我们可以通过插件往Webpack工作过程的任意环节植入一些自定义的任务,从而扩展Webpack
 * 打包功能以外的能力.
 */

/**
 * 二,工作原理剖析
 * 先提炼出Webpack核心工作过程中的关键环节,明确"查阅"源码的思路:
 * 1> Webpack CLI 启动打包流程
 * 2> 载入Webpack核心模块,创建Compiler对象;
 * 3> 使用Compiler对象开始编译整个项目;
 * 4> 从入口文件开始,解析模块依赖,形成依赖关系树;
 * 5> 递归依赖树,将每个模块交给对应的Loader处理;
 * 6> 合并Loader处理完的结果,将打包结果输出到dist目录;
 */

/**
 * 1. Webpack CLI
 * 从Webpack 4 开始 Webpack 的CLI部分就被单独抽到了 webpack-cli 模块中,目的就是为了增强Webpack本身的灵活性.
 * 这里分析的是V3.3.11版本的webpack-cli,可参考:https://github.com/webpack/webpack-cli/tree/v3.3.11
 * 
 * Webpack CLI的作用就是将CLI参数和Webpack配置文件中配置整合,得到一个完整的配置对象.
 * 这部分操作在webpack-cli的入口文件bin/cli.js中.
 * 首先,Webpack CLI 会通过 yargs 模块解析CLI参数,所谓CLI参数值的就是我们在运行webpack命令是通过命令行传入的
 * 参数,例如 --mode=production,具体位置如下图:
 * 
 * 05.2 示例图
 * 
 * 紧接着后面,调用了 bin/utils/convert-argv.js模块,将得到的命令行参数转换为Webpack的配置选项对象,如下图:
 * 
 * 05.3 实例图
 * 
 * 在convert-argv.js工作过程中,首先为传递过来的命令行参数设置了默认值,然后判断了命令行参数中是否制定了一个具体的配置
 * 文件路径,如果指定了就加载指定配置文件,反之则需要根据默认配置文件加载规则找到配置文件,如下:
 * 
 * 05.4 实例图
 * 
 * 找到配置文件过后,将配置文件中的配置和CLI参数中的配置合并,如果出现重复的情况,会优先使用CLI参数,最终得到一个完整的配置选项.
 * 
 * 有了配置选项过后,开始载入Webpack核心模块,传入配置选项,创建Compiler对象,这个Compiler对象就是整个Webpack工作过程中
 * 最核心的对象了,负责完成整个项目的构建工作.如下:
 * 
 * 05.5 示例图
 * 
 */

/**
 * 2. 创建Compiler对象
 * 随着Webpack CLI 载入 Webpack核心模块,这个执行过程就到了Webpack模块中,所以需要回到Webpack模块中,这里分析的是v4.43.0版本的Webpack,
 * 版本:https://github.com/webpack/webpack/tree/v4.43.0
 * 
 * 同样,这里需要找到这个模块的入口文件,就是lib/webpack.js文件,这个文件导出的是一个用于创建Compiler的函数,如下:
 * 
 * 05.6
 * 
 * 在图05.6这个函数中,首先校验了外部传递过来的options参数是否符合要求,紧接着判断了options的类型,
 * 
 * 根据这个函数中的代码,发现options不仅可以是一个对象,还可以是一个数组,若传入的是一个数组,那么Webpack内部创建的就是一个MultiCompiler,也就是说
 * Webpack应该支持同时开启多路打包,配置数组中的每个成员就是一个独立的配置选项,而如果传入的是普通的对象,会按照最熟悉的方式创建一个Compiler对象,进行
 * 单线打包,如图
 * 
 * 05.7 示例图
 * 
 * 顺着主线接着往下看,如下图所示,在创建了Compiler对象后,Webpack就开始注册我们配置中的每个插件,因为在往后Webpack工作过程的声明周期就要开始,所以
 * 必须先注册,这样才能确保插件中的每个钩子都能被命中.如图
 * 
 * 05.8 示例图
 */

/**
 * 三,开始构建
 * 完成Compiler对象的创建过后,紧接着这里的代码开始判断配置选项中是否启用了监视模式,如下:
 * 
 * 05.9 示例图
 * > 如果是监视模式就调用Compiler对象的watch方法,以监视模式启动构建,但这不是我们主要关心的主线.
 * > 如果不是监视模式就调用Compiler对象的run方法,开始构建整个应用.
 * 
 * 这个run方法定义在Compiler类型中,具体文件在webpack模块下的 lib/Compiler.js中,如下:
 * 
 * 05.10 示例图
 * 
 * 这个方法内部就是先触发了beforeRun和run两个钩子,最后最关键的是调用了当前对象的compile方法,真正开始
 * 编译整个项目,如下:
 * 
 * 05.11 示例图
 * 
 * compile方法内部主要就是创建了一个Compilation对象,这个对象在04节课中有提到,可理解为一次构建过程的
 * 上下文对象,里面包含了这次构建中全部的资源和信息.
 * 
 * 05.12 示例图
 * 
 * 创建完Compilation对象过后,紧接着触发了一个叫做make的钩子,进入整个构建过程最核心的make阶段.
 * 
 */

/**
 * 四, make 阶段
 * make阶段主体的目标:
 * 根据entry配置找到入口模块,开始依次递归出所有依赖,形成依赖关系树,然后将递归到的每个模块交给不同
 * 的Loader处理. 如下:
 * 
 * 05.13 示例图
 * 
 * 由于这个阶段的调用过程并不像之前一样,直接调用某个对象的某个方法,而是采用事件触发机制,让外部
 * 监听这个make事件的地方开始执行.
 * 
 * 想要知道这个事件触发后,哪些地方会开始执行,前提是得知道哪里注册了这个叫做make的事件.
 * 
 * Webpack的插件系统是基于官方自己的Tapable实现的,想要知道在哪里注册了某个时间,必须要知道如何注册事件.
 * Tapable的注册方式如下:
 * 
 * 05.14 示例图
 * 
 * 所以,只需要通过开发工具搜索源代码的make.tap, 就应该能够找到事件注册的位置,如下:
 * 
 * 05.15 示例图
 * 
 * 这里搜索到了六个插件中都注册了make事件,这些插件实际上是前面创建Compiler对象的时候创建的.
 * 
 * 05.16 示例图
 * 
 * 因为默认使用的就是单一入口打包的方式,所以这里最终会执行其中的 SingleEntryPlugin.
 * 
 * 05.17 示例图
 * 
 * 这个插件中调用了Compilation对象的 addEntry 方法,开始解析源代码中的入口文件,以此开始 "顺藤摸瓜" 方式的寻找.
 * 对于make阶段后续的流程,大致为:
 * 
 * 1 > SingleEntryPlugin中调用了Compilation对象的addEntry方法,开始解析入口;
 * 2 > addEntry方法中又调用了_addModuleChain方法,将入口模块添加到模块依赖列表中;
 * 3 > 紧接着通过Compilation对象的buildModule方法进行模块构建;
 * 4 > buildModule方法中执行具体的Loader,处理特殊资源加载;
 * 5 > build完成后,通过 acorn 库生成模块代码的AST语法树;
 * 6 > 根据语法树分析这个模块是否还有依赖的模块,如果有则继续循环build每个依赖;
 * 7 > 所有依赖解析完成,build阶段结束;
 * 8 > 最后合并生成需要输出的bundle.js写入dist目录.
 */